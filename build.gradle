plugins {
    id 'java'
    id 'org.jetbrains.kotlin.jvm' version '1.3.72'
    id 'application'
}

group 'org.example'
version '1.0-SNAPSHOT'

mainClassName = 'app.MainClass'  //指定id 'application'后，Tasks中会出现application的run方法，点击后会执行mainClassName指定类的main方法
/**
 * > Task :run
 * Hello World!
 */

repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
}

task task1 {  //task("task1")简化，因为()和""可以省略
    //任务配置:在项目的配置阶段运行
    println "这是一个最简单的任务"
    //任务行为:在项目的执行阶段运行
    doFirst {   //1.在任务内部定义
        println "task1 doFirst"
    }
    doLast {
        println "task1 doLast"
    }
}

//2.在任务外部定义
task1.doFirst {
    println "task1 doFirst outer"
}

task1.doLast {
    println "task1 doLast outer"
}

/**
 * 执行任务
 * gradle clean
 * gradle -i task1
 */

def map = new HashMap<String, Object>()
//设置task的action，可以是一个闭包
map.put("action", { println("task two...") })

task(map, "task2") {   //对应构造函数：Task task(Map<String, ?> args, String name, Closure configureClosure);
    //任务配置:在项目的配置阶段运行
    println "这是一个最简单的任务"
    //任务行为:在项目的执行阶段运行
    doFirst {   //1.在任务内部定义
        println "task2 doFirst"
    }
    doLast {
        println "task2 doLast"
    }
}

//2.在任务外部定义
task2.doFirst {
    println "task2 doFirst outer"   //First:插入队列头部
}

task2.doLast {
    println "task2 doLast outer"   //Last:插入队列尾部
}
compileKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}
compileTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

/**
 * task生命周期：
 * 1.先读取settings.gradle文件
 * 2.Configure配置阶段：println "这是一个最简单的任务"
 * 3.执行阶段, 按照队列插入不同任务:
 *   task2 doFirst outer
 *   task2 doFirst
 *   task two...
 *   task2 doLast
 *   task2 doLast outer
 */

//自定义删除任务(type:Delete)，删除build目录
tasks.register('myClean', Delete) {
    delete buildDir
}

4.times { counter ->
    tasks.register("task${counter}_new") {
        doLast {
            println("I'm task${counter}_new")
        }
    }
}


task2_new.enabled = false   //跳过task2_new的执行
tasks.named('task0_new') { dependsOn('task2_new', 'task3_new') }
/** 执行task0_new：
 * > Task :task2_new SKIPPED
 *
 * > Task :task3_new
 * I'm task3_new
 *
 * > Task :task0_new
 * I'm task0_new
 */

//文件
def configFile = file('src/conf.xml')   //相对路径，也可以用绝对路径如'D:\\conf.xml'
//file('src/conf.xml')等同于java写法 new File('src/conf.xml')
configFile.createNewFile()   //创建文件

//文件集合
def fileCollection = files('src/text1.txt', 'src/text2.txt', 'src/text3.txt')
def fileSet = fileCollection as Set   //转成Set，也可以转成List
fileSet.forEach( { item ->
    item.createNewFile()
//    item.exists()
})

//文件树
def configFileTree = fileTree('src/main')    //操作src下的main目录
configFileTree.include("**/*.java").forEach( { item ->  //include("**/*.java")代表仅保留.java结尾的文件；exclude则是排除不符合的文件
    println item.name
})
/**由于过滤了java结尾的文件，仅打印
 * MainClass.java
 * test.java
 * 不会打印 testconfig.xml
 */