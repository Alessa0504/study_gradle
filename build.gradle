//内部插件DSL方式
plugins {
    id 'java'
    id 'org.jetbrains.kotlin.jvm' version '1.3.72'
    id 'application'
    id 'java-library'   //要使用api依赖方式必须引入java-library插件
}
//内部插件apply方式: key-plugin, value-插件id或全类名或简类名JavaPlugin(包已经默认导入)
apply(plugin: 'java')  //可以省略()即apply plugin: 'java'

//脚本插件
apply from: "version.gradle"  //引入自定义脚本文件version.gradle

task taskVersion {
    doLast {
        println "公司名：$company, JDK版本是 ${cfgs.compileSdkVersion}"
    }
}

//应用buildSrc目录下自定义插件
apply plugin: 'testPluginId'   //*这里写的是插件id即resources/META-INF/gradle-plugins/testPluginId.properties文件的.properties前缀

group 'org.example'
version '1.0-SNAPSHOT'

mainClassName = 'app.MainClass'  //指定id 'application'后，Tasks中会出现application的run方法，点击后会执行mainClassName指定类的main方法
/**
 * > Task :run
 * Hello World!
 */

repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    //本地依赖：通过files
    implementation files('lib/mysql.jar', 'lib/log4j.jar')  //本地依赖root下lib目录下的mysql.jar和log4j.jar
    //本地依赖：通过fileTree
    implementation fileTree('dir':'lib', includes: ['*.jar'], excludes: ['lib/log4j.jar'])  //依赖lib目录下的.jar结尾文件，排除log4j.jar
    //直接依赖maven: 依赖类型implementation，依赖的组名+依赖的名称+依赖的版本号，也可省略key中间用:隔开
    implementation group: 'org.apache.karaf.log', name: 'log', version: '3.0.10'
    //简写 implementation 'org.apache.karaf.log:log:3.0.10'
    //项目依赖
    implementation project(':subproject01')
//    api：依赖可传递

    //依赖冲突
    implementation('org.jetbrains.kotlin:kotlin-stdlib-jdk8:1.3.72') {  //org.jetbrains.kotlin:kotlin-stdlib-jdk8中也依赖了org.jetbrains.kotlin:kotlin-stdlib，版本是1.3.72小于手动引入的1.9.22，所以内部依赖的版本也会更新为1.3.73
//        exclude group:'org.jetbrains.kotlin'   //排除依赖(没用???)
        exclude module: 'kotlin-stdlib'
//        transitive(true)
    }
    implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.9.22'  //手动引入的1.9.22
//    implementation 'org.jetbrains.kotlin:kotlin-stdlib:+'  //手动引入最新版本用+，会去repositories中定义的(目前只有mavenCentral())中下载，当然有其他仓库也会遍历所有仓库找最新版本下载 --不建议
}

//查看当前项目有哪些冲突:当gradle构建遇到依赖冲突时，就立即构建失败，即不使用默认策略：自动跟新版本
//configurations.all { Configuration configuration ->
//    //当gradle构建遇到依赖冲突时，就立即构建失败
//    configuration.resolutionStrategy.failOnVersionConflict()
//}
/** 执行后会报错：
 * Conflict(s) found for the following module(s):
 *   - org.jetbrains.kotlin:kotlin-stdlib between versions 1.9.22 and 1.3.72
 */


task task1 {  //task("task1")简化，因为()和""可以省略
    //任务配置:在项目的配置阶段运行
    println "这是一个最简单的任务"
    //任务行为:在项目的执行阶段运行
    doFirst {   //1.在任务内部定义
        println "task1 doFirst"
    }
    doLast {
        println "task1 doLast"
    }
}

//2.在任务外部定义
task1.doFirst {
    println "task1 doFirst outer"
}

task1.doLast {
    println "task1 doLast outer"
}

/**
 * 执行任务
 * gradle clean
 * gradle -i task1
 */

def map = new HashMap<String, Object>()
//设置task的action，可以是一个闭包
map.put("action", { println("task two...") })

task(map, "task2") {   //对应构造函数：Task task(Map<String, ?> args, String name, Closure configureClosure);
    //任务配置:在项目的配置阶段运行
    println "这是一个最简单的任务"
    //任务行为:在项目的执行阶段运行
    doFirst {   //1.在任务内部定义
        println "task2 doFirst"
    }
    doLast {
        println "task2 doLast"
    }
}

//2.在任务外部定义
task2.doFirst {
    println "task2 doFirst outer"   //First:插入队列头部
}

task2.doLast {
    println "task2 doLast outer"   //Last:插入队列尾部
}
compileKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}
compileTestKotlin {
    kotlinOptions {
        jvmTarget = "1.8"
    }
}

/**
 * task生命周期：
 * 1.先读取settings.gradle文件
 * 2.Configure配置阶段：println "这是一个最简单的任务"
 * 3.执行阶段, 按照队列插入不同任务:
 *   task2 doFirst outer
 *   task2 doFirst
 *   task two...
 *   task2 doLast
 *   task2 doLast outer
 */

//自定义删除任务(type:Delete)，删除build目录
tasks.register('myClean', Delete) {
    delete buildDir
}

4.times { counter ->
    tasks.register("task${counter}_new") {
        doLast {
            println("I'm task${counter}_new")
        }
    }
}


task2_new.enabled = false   //跳过task2_new的执行
tasks.named('task0_new') { dependsOn('task2_new', 'task3_new') }
/** 执行task0_new：
 * > Task :task2_new SKIPPED
 *
 * > Task :task3_new
 * I'm task3_new
 *
 * > Task :task0_new
 * I'm task0_new
 */

//文件
def configFile = file('src/conf.xml')   //相对路径，也可以用绝对路径如'D:\\conf.xml'
//file('src/conf.xml')等同于java写法 new File('src/conf.xml')
configFile.createNewFile()   //创建文件

//文件集合
def fileCollection = files('src/text1.txt', 'src/text2.txt', 'src/text3.txt')
def fileSet = fileCollection as Set   //转成Set，也可以转成List
fileSet.forEach( { item ->
    item.createNewFile()
//    item.exists()
})

//文件树
def configFileTree = fileTree('src/main')    //操作src下的main目录
configFileTree.include("**/*.java").forEach( { item ->  //include("**/*.java")代表仅保留.java结尾的文件；exclude则是排除不符合的文件
    println item.name
})
/**由于过滤了java结尾的文件，仅打印
 * MainClass.java
 * test.java
 * 不会打印 testconfig.xml
 */

//文件拷贝
task copyTask(type: Copy) {   //自定义一个Copy类型的任务叫copyTask
//    from('src/main/java/test.java')  //拷贝单个文件
    from 'src/main/'   //拷贝目录下的所有文件
    include('**/*.java')  //仅java结尾文件
    rename { String fileName ->
        fileName.replace('test', 'MyTest')   //对test.java重命名
    }
    into 'build/exportTest'   //把test.java拷贝至build/exportTest目录下
}
//或直接使用project对象的copy方法；执行build任务时会自动执行copy方法
copy {
    from 'src/main/'   //拷贝目录下的所有文件
    include('**/*.java')  //仅java结尾文件
    rename { String fileName ->
        fileName.replace('test', 'MyTest')   //对test.java重命名
    }
    into 'build/exportTest'   //把test.java拷贝至build/exportTest目录下
}

//自定义插件 官网例子：https://docs.gradle.org/current/userguide/custom_plugins.html
class GreetingPlugin implements Plugin<Project> {

    @Override
    void apply(Project target) {
        target.task('hello') {  //创建任务hello
            doLast {
                println 'Hello from the GreetingPlugin'
            }
        }
    }
}
//应用插件
apply plugin: GreetingPlugin
/**
 * 执行任务：gradle -q hello
 * 打印 Hello from the GreetingPlugin
 */